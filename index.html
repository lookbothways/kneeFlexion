<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Knee Flexion Trainer</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #222;
            color: white;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }
        /* Hide the raw video, we render to canvas */
        video { display: none; }

        canvas {
            border: 2px solid #555;
            background-color: #000;
            max-width: 100%;
            /* Ensure it doesn't get too tall on mobile so controls are visible */
            max-height: 80vh;
        }

        .controls {
            margin-top: 15px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            justify-content: center;
        }

        /* New class for the description text */
        .description {
            margin-top: 15px;
            max-width: 600px;
            text-align: center;
            font-size: 16px;
            color: #ddd;
            line-height: 1.5;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            transition: background 0.2s;
        }
        button:disabled { background-color: #555; cursor: not-allowed; }

        /* Specific Button Colors */
        button#btn-start { min-width: 150px; }
        button#btn-download { background-color: #28a745; display: none; }
        button#btn-toggle-leg { background-color: #17a2b8; } /* Teal */
        button#btn-toggle-leg:hover { background-color: #138496; }

        button#btn-set-angle { background-color: #6610f2; } /* Purple */
        button#btn-set-angle:hover { background-color: #520dc2; }

        /* Input styling */
        #angle-controls {
            align-items: center;
            background: #333;
            padding: 10px;
            border-radius: 5px;
            margin-top: 10px;
        }
        #inp-target-angle {
            font-size: 16px;
            padding: 5px;
            width: 70px;
            border-radius: 3px;
            border: 1px solid #555;
            margin: 0 10px;
            text-align: center;
        }

        /* Status messages */
        #status-loading {
            margin-bottom: 10px;
            padding: 10px;
            background: #333;
            border-radius: 4px;
            border: 1px solid #444;
        }
        .error {
            color: #ff6b6b;
            border-color: #ff6b6b !important;
            background: #3d0000 !important;
        }
    </style>
</head>
<body>

    <h1 id="page-title">Knee Flexion session: 10x 10sec 90&deg;</h1>
    <div id="status-loading">Loading... </div>

    <div style="position: relative;">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="output_canvas"></canvas>
    </div>

    <!-- Main Controls -->
    <div class="controls">
        <button id="btn-start" disabled>Start Camera</button>
        <button id="btn-toggle-leg">Leg: Left</button>
        <button id="btn-set-angle">Target Angle</button>
        <button id="btn-download">Download Session Log</button>
    </div>

    <!-- Hidden Angle Input -->
    <div id="angle-controls" style="display: none;">
        <label for="inp-target-angle">Target Angle (&deg;):</label>
        <input type="number" id="inp-target-angle" value="90" min="10" max="175">
        <button id="btn-confirm-angle" style="background-color: #28a745; padding: 5px 15px;">OK</button>
    </div>

    <p class="description">
        Track knee flexibility for physio reps. Position yourself side-on to the camera in ample light, start the camera, bend the knee to reach the target angle and hold it to complete a rep.
    </p>

<script type="module">
    import { PoseLandmarker, FilesetResolver, DrawingUtils } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/vision_bundle.mjs";

    // --- CONFIGURATION ---
    const BUFFER_SIZE = 3;
    let targetAngle = 90;
    const HOLD_DURATION = 10;
    const REST_DURATION = 5;
    const MAX_REPS = 10;

    const UI_BG_COLOR = "#808080";
    const TEXT_COLOR = "#FFFFFF";

    // Landmark Indices Maps
    // Swapped because video is flipped
    const LEG_INDICES = {
        LEFT: { hip: 23, knee: 25, ankle: 27 },
        RIGHT:  { hip: 24, knee: 26, ankle: 28 }
    };

    // --- STATE VARIABLES ---
    let poseLandmarker = undefined;
    let webcamRunning = false;
    let lastVideoTime = -1;
    let state = "WAITING";
    let repsCompleted = 0;
    let timerStart = 0;
    let sessionLogged = false;

    let currentLeg = "LEFT"; // Default

    // Buffers
    let hipBuffer = [];
    let kneeBuffer = [];
    let ankleBuffer = [];
    let angleBuffer = [];

    // DOM Elements
    const video = document.getElementById("webcam");
    const canvasElement = document.getElementById("output_canvas");
    const canvasCtx = canvasElement.getContext("2d");
    const startBtn = document.getElementById("btn-start");
    const toggleLegBtn = document.getElementById("btn-toggle-leg");
    const downloadBtn = document.getElementById("btn-download");
    const loadingMsg = document.getElementById("status-loading");
    const pageTitle = document.getElementById("page-title");

    // Angle Input Elements
    const setAngleBtn = document.getElementById("btn-set-angle");
    const angleControls = document.getElementById("angle-controls");
    const inpTargetAngle = document.getElementById("inp-target-angle");
    const confirmAngleBtn = document.getElementById("btn-confirm-angle");

    // --- SETUP MEDIAPIPE ---
    const createPoseLandmarker = async () => {
        try {
            const vision = await FilesetResolver.forVisionTasks(
                "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.14/wasm"
            );

            poseLandmarker = await PoseLandmarker.createFromOptions(vision, {
                baseOptions: {
                    modelAssetPath: `https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_full/float16/1/pose_landmarker_full.task`,
                    delegate: "GPU"
                },
                runningMode: "VIDEO",
                numPoses: 1
            });

            loadingMsg.style.display = "none";
            startBtn.disabled = false;
            console.log("Model loaded successfully");

        } catch (error) {
            console.error(error);
            loadingMsg.textContent = "Error: " + error.message;
            loadingMsg.className = "error";
        }
    };

    createPoseLandmarker();

    // --- MATH HELPERS ---
    function calculateFlexion(a, b, c) {
        let radians = Math.atan2(c.y - b.y, c.x - b.x) - Math.atan2(a.y - b.y, a.x - b.x);
        let angle = Math.abs(radians * 180.0 / Math.PI);
        if (angle > 180.0) angle = 360 - angle;
        return Math.floor(Math.abs(180 - angle));
    }

    function getAveragePoint(buffer) {
        if (buffer.length === 0) return null;
        let sumX = 0, sumY = 0;
        for (let p of buffer) { sumX += p.x; sumY += p.y; }
        return { x: sumX / buffer.length, y: sumY / buffer.length };
    }

    function updateBuffer(buffer, point) {
        buffer.push(point);
        if (buffer.length > BUFFER_SIZE) buffer.shift();
    }

    // --- CONTROLS ---

    // Toggle Leg Button
    toggleLegBtn.addEventListener("click", () => {
        if (currentLeg === "RIGHT") {
            currentLeg = "LEFT";
            toggleLegBtn.innerText = "Leg: Left";
        } else {
            currentLeg = "RIGHT";
            toggleLegBtn.innerText = "Leg: Right";
        }
        hipBuffer = [];
        kneeBuffer = [];
        ankleBuffer = [];
        angleBuffer = [];
    });

    // Angle Configuration
    setAngleBtn.addEventListener("click", () => {
        if (angleControls.style.display === "none") {
            angleControls.style.display = "flex";
            inpTargetAngle.value = targetAngle;
            inpTargetAngle.focus();
        } else {
            angleControls.style.display = "none";
        }
    });

    confirmAngleBtn.addEventListener("click", () => {
        const val = parseInt(inpTargetAngle.value);
        if (val && val > 10 && val < 180) {
            targetAngle = val;
            angleControls.style.display = "none";
            pageTitle.innerHTML = `Knee Flexion session: 10x 10sec ${targetAngle}&deg;`;
        } else {
            alert("Please enter a valid angle between 10 and 179.");
        }
    });

    // Camera Button
    function enableCam(event) {
        if (!poseLandmarker) return;

        if (webcamRunning === true) {
            webcamRunning = false;
            startBtn.innerText = "Start Camera";
            startBtn.style.backgroundColor = "#007bff";
            if(video.srcObject) {
                video.srcObject.getTracks().forEach(track => track.stop());
                video.srcObject = null;
            }
        } else {
            webcamRunning = true;
            startBtn.innerText = "Stop Camera";
            startBtn.style.backgroundColor = "#dc3545";

            const constraints = { video: { width: 640, height: 480 } };

            navigator.mediaDevices.getUserMedia(constraints).then((stream) => {
                video.srcObject = stream;
                video.addEventListener("loadeddata", predictWebcam);
            }).catch((err) => {
                console.error(err);
                alert("Camera access denied. Please allow camera permissions.");
                webcamRunning = false;
                startBtn.innerText = "Start Camera";
                startBtn.style.backgroundColor = "#007bff";
            });
        }
    }
    startBtn.addEventListener("click", enableCam);

    // --- MAIN LOOP ---
    async function predictWebcam() {
        if (!webcamRunning) return;

        // Check if layout needs to change based on window size (Mobile Portrait vs Desktop)
        // We do this check every frame or we could listen to resize events.
        // Doing it here ensures the canvas is always the right shape.
        const isPortrait = window.innerHeight > window.innerWidth;
        const vidW = video.videoWidth;
        const vidH = video.videoHeight;

        let targetCanvasW, targetCanvasH;

        if (isPortrait) {
            // Stacked: Video Top, UI Bottom
            targetCanvasW = vidW;
            targetCanvasH = vidH * 2;
        } else {
            // Side-by-side: Video Left, UI Right
            targetCanvasW = vidW * 2;
            targetCanvasH = vidH;
        }

        if(canvasElement.width !== targetCanvasW || canvasElement.height !== targetCanvasH) {
            canvasElement.width = targetCanvasW;
            canvasElement.height = targetCanvasH;
        }

        let startTimeMs = performance.now();

        if (lastVideoTime !== video.currentTime) {
            lastVideoTime = video.currentTime;
            poseLandmarker.detectForVideo(video, startTimeMs, (result) => {
                processFrame(result, vidW, vidH, isPortrait);
            });
        }

        window.requestAnimationFrame(predictWebcam);
    }

    function processFrame(result, w, h, isPortrait) {
        const currTime = Date.now() / 1000;

        // 1. Draw Background
        canvasCtx.save();
        canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

        // -- DRAW VIDEO --
        // In both layouts, video is at 0,0
        canvasCtx.translate(w, 0);
        canvasCtx.scale(-1, 1);
        if(video.srcObject) canvasCtx.drawImage(video, 0, 0, w, h);
        canvasCtx.restore();

        // -- DRAW UI BACKGROUND --
        canvasCtx.fillStyle = UI_BG_COLOR;
        let uiStartX, uiStartY;

        if (isPortrait) {
            // UI goes below video
            uiStartX = 0;
            uiStartY = h;
            canvasCtx.fillRect(0, h, w, h);
        } else {
            // UI goes to the right of video
            uiStartX = w;
            uiStartY = 0;
            canvasCtx.fillRect(w, 0, w, h);
        }

        let smoothAngle = 0;

        // 2. Logic & Skeleton
        if (result.landmarks && result.landmarks.length > 0) {
            const lm = result.landmarks[0];
            const idx = LEG_INDICES[currentLeg];

            // Calc coords (Flipping X for mirror effect)
            // Video is always drawn at 0,0 so these coords are valid for the video region
            const rawHip = { x: (1 - lm[idx.hip].x) * w, y: lm[idx.hip].y * h };
            const rawKnee = { x: (1 - lm[idx.knee].x) * w, y: lm[idx.knee].y * h };
            const rawAnkle = { x: (1 - lm[idx.ankle].x) * w, y: lm[idx.ankle].y * h };

            updateBuffer(hipBuffer, rawHip);
            updateBuffer(kneeBuffer, rawKnee);
            updateBuffer(ankleBuffer, rawAnkle);

            const sHip = getAveragePoint(hipBuffer);
            const sKnee = getAveragePoint(kneeBuffer);
            const sAnkle = getAveragePoint(ankleBuffer);

            if (sHip && sKnee && sAnkle) {
                const currentAngle = calculateFlexion(sHip, sKnee, sAnkle);

                angleBuffer.push(currentAngle);
                if (angleBuffer.length > BUFFER_SIZE) angleBuffer.shift();
                smoothAngle = Math.floor(angleBuffer.reduce((a, b) => a + b, 0) / angleBuffer.length);

                // Draw Lines on the video part
                canvasCtx.lineWidth = 3;
                canvasCtx.strokeStyle = "white";
                canvasCtx.beginPath();
                canvasCtx.moveTo(sHip.x, sHip.y);
                canvasCtx.lineTo(sKnee.x, sKnee.y);
                canvasCtx.lineTo(sAnkle.x, sAnkle.y);
                canvasCtx.stroke();

                canvasCtx.fillStyle = "#00FF00";
                canvasCtx.beginPath();
                canvasCtx.arc(sKnee.x, sKnee.y, 8, 0, 2 * Math.PI);
                canvasCtx.fill();

                // State Machine
                if (state === "WAITING") {
                    drawBigText(`${smoothAngle}Â°`, uiStartX, uiStartY, w, h);
                    if (smoothAngle >= targetAngle) {
                        state = "HOLDING";
                        timerStart = currTime;
                    }
                } else if (state === "HOLDING") {
                    if (smoothAngle < targetAngle) {
                        state = "WAITING";
                    } else {
                        const elapsed = currTime - timerStart;
                        const remaining = Math.max(0, HOLD_DURATION - Math.floor(elapsed));
                        drawBigText(`HOLD: ${remaining}s`, uiStartX, uiStartY, w, h);
                        if (elapsed >= HOLD_DURATION) {
                            repsCompleted++;
                            if (repsCompleted >= MAX_REPS) {
                                state = "FINISHED";
                            } else {
                                state = "RESTING";
                                timerStart = currTime;
                            }
                        }
                    }
                } else if (state === "RESTING") {
                    const elapsed = currTime - timerStart;
                    const remaining = Math.max(0, REST_DURATION - Math.floor(elapsed));
                    drawBigText(`REST: ${remaining}s`, uiStartX, uiStartY, w, h);
                    if (elapsed >= REST_DURATION) state = "WAITING";
                }
            }
        }

        // 3. UI Text
        // Define padding for text
        const textX = uiStartX + 40;
        const textYStart = uiStartY + 60;
        const lineHeight = 50;

        canvasCtx.fillStyle = TEXT_COLOR;
        canvasCtx.font = "bold 40px Arial";
        canvasCtx.fillText(`STATUS: ${state}`, textX, textYStart);

        canvasCtx.font = "36px Arial";
        canvasCtx.fillText(`LEG: ${currentLeg}`, textX, textYStart + lineHeight);
        canvasCtx.fillText(`CURRENT FLEXION: ${smoothAngle} deg`, textX, textYStart + lineHeight*2);
        canvasCtx.fillText(`TARGET ANGLE: ${targetAngle} deg`, textX, textYStart + lineHeight*3);
        canvasCtx.fillText(`REPS: ${repsCompleted} / ${MAX_REPS}`, textX, textYStart + lineHeight*4);

        if (state === "FINISHED") {
            canvasCtx.fillStyle = "#FFFFFF";
            canvasCtx.font = "bold 40px Arial";
            // Centered in UI box
            canvasCtx.fillText("SESSION COMPLETE", textX, uiStartY + h/2 + 40);
            if (!sessionLogged) {
                sessionLogged = true;
                downloadBtn.style.display = "block";
            }
        }
    }

    function drawBigText(text, uiStartX, uiStartY, w, h) {
        // Center the big text in the UI panel
        const centerX = uiStartX + (w / 2);
        const centerY = uiStartY + (h * 0.75); // Place it in the bottom/lower half of the UI panel

        canvasCtx.fillStyle = TEXT_COLOR;
        canvasCtx.font = "bold 70px Arial";
        canvasCtx.textAlign = "center";
        canvasCtx.fillText(text, centerX, centerY);
        canvasCtx.textAlign = "start"; // Reset alignment
    }

    // --- DOWNLOAD CSV ---
    downloadBtn.addEventListener('click', () => {
        const timestamp = new Date().toISOString().replace('T', ' ').substring(0, 19);
        const csvContent = "data:text/csv;charset=utf-8,Timestamp,Leg,Target_Angle\n" + `${timestamp},${currentLeg},${targetAngle} deg`;
        const encodedUri = encodeURI(csvContent);
        const link = document.createElement("a");
        link.setAttribute("href", encodedUri);
        link.setAttribute("download", "knee_session_log.csv");
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    });
</script>
</body>
</html>